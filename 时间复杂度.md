### 时间复杂度

在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。

```c
// 请计算一下Func1中++count语句总共执行了多少次？
void Func1(int N)
{
int count = 0;
for (int i = 0; i < N ; ++ i)
{
 for (int j = 0; j < N ; ++ j)
 {
 ++count;        //这里count++执行N*N次
 }
}
 
for (int k = 0; k < 2 * N ; ++ k)
{
 ++count;        //这里count++执行2*N次
}
int M = 10;
while (M--)
{
 ++count;        //这里count++执行M次
}
 
 
//所以++count总共执行  N^2+2*N+M 次
```

#### 大O的渐进表示法

大O符号（Big O notation）：是用于描述函数渐进行为的数学符号。

O()括号里面的数更多的表达的是这个算法的量级，大O是一个估算，并不是准确的执行次数。



**推导大O阶方法：**

**1、用常数1取代运行时间中的所有加法常数。**

**2、在修改后的运行次数函数中，只保留最高阶项。**

**3、如果最高阶项系数存在且不是1，则去除与这个项目相乘的常数。得到的结果就是大O阶。**

**大O的渐进表示法去掉了那些对结果影响不大的项，简洁明了的表示出了执行次数。**

```c
// 计算Func2的时间复杂度？
void Func2(int N)           
{
 int count = 0;
 for (int k = 0; k < 2 * N ; ++ k)
 {
 ++count;        //2*N
 }
 int M = 10;
 while (M--)
 {
 ++count;        //10
 }
 printf("%d\n", count);
}
 
//2*N+10
//当N趋于无限大的时候，10和2对于整体的效果影响不大，所以舍去得到N
//注意N和2*N+10是一个量级的
//
//所以Fun2的算法复杂度为   O(N)=N
```

#### *常见时间复杂度计算案例*

##### 计算两个循环分别对应两个变量有关的时间复杂度

```c
// 计算Func3的时间复杂度？
void Func3(int N, int M)
{
	int count = 0;
	for (int k = 0; k < M; ++k)
	{
		++count;
	}
	for (int k = 0; k < N; ++k)
	{
		++count;
	}
	printf("%d\n", count);
}
```

![img](https://i-blog.csdnimg.cn/blog_migrate/078607254310ab218404b7601dca1fdb.png)

##### 计算只与常量数字有关的时间复杂度

```c
 
// 计算Func4的时间复杂度？
void Func4(int N)
{
	int count = 0;
	for (int k = 0; k < 100; ++k)
	{
		++count;
	}
	printf("%d\n", count);
}
```

![img](https://i-blog.csdnimg.cn/blog_migrate/f65fe17f15751e873cb81eb51a9450ee.png)

##### 计算 strchr 的时间复杂度

```c
// 计算strchr的时间复杂度？
const char * strchr ( const char * str, int character );
```

![img](https://i-blog.csdnimg.cn/blog_migrate/7b4c28a0d86edfddfa543186f60a91e0.png)

##### 计算冒泡排序 BubbleSort 的时间复杂度

```c
// 计算BubbleSort的时间复杂度？
void BubbleSort(int* a, int n)
{
 assert(a);
 for (size_t end = n; end > 0; --end)
 {
 int exchange = 0;
 for (size_t i = 1; i < end; ++i)
 {
 if (a[i-1] > a[i])
 {
 Swap(&a[i-1], &a[i]);
 exchange = 1;
 }
 }
 if (exchange == 0)
 break;
 }
}
```

![img](https://i-blog.csdnimg.cn/blog_migrate/78e5229f1afd681a6d0b1390811315c0.png)

##### 计算二分法BinarySearch的时间复杂度

```c
// 计算BinarySearch的时间复杂度？
int BinarySearch(int* a, int n, int x)
{
 assert(a);
 int begin = 0;
 int end = n-1;
 // [begin, end]：begin和end是左闭右闭区间，因此有=号
 while (begin <= end)
 {
 int mid = begin + ((end-begin)>>1);
 if (a[mid] < x)
 begin = mid+1;
 else if (a[mid] > x)
 end = mid-1;
 else
 return mid;
 }
 return -1;
}
```

![img](https://i-blog.csdnimg.cn/blog_migrate/3cc14314d31987e63c0ea5fe126826c1.png)

##### 计算阶乘递归的时间复杂度

```c
 
// 计算阶乘递归Fac的时间复杂度？
long long Fac(size_t N)
{
	if (0 == N)
		return 1;
 
	return Fac(N - 1) * N;
}
```

![img](https://i-blog.csdnimg.cn/blog_migrate/a9eb94d6cbd85a742e997462afbe34cd.png)